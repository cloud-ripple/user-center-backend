<a name="EUA18"></a>
# 1 准备工作
<a name="RvMBY"></a>
## 1.1 后端项目初始化
引入依赖
```xml
<!--   mybatis     -->
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter-test</artifactId>
    <version>2.3.1</version>
    <scope>test</scope>
</dependency>
<!-- mybatis-plus -->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.5.1</version>
</dependency>
```
yml配置
```yaml
spring:
  application:
    name: user-center
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: twb
    url: jdbc:mysql://localhost:3306/user_center

server:
  port: 8080

# mapUnderscoreToCamelCase 是否开启自动驼峰命名规则（camel case）映射，
  #即从经典数据库列名 A_COLUMN（下划线命名） 到经典 Java 属性名 aColumn（驼峰命名） 的类似映射。
mybatis-plus:
  configuration:
    map-underscore-to-camel-case: false
```
```sql
create table user
(
    id           bigint auto_increment primary key comment '主键ID',
    username     varchar(256) default ''                null comment '用户昵称',
    userAccount  varchar(256)                           null comment '账号',
    avatarUrl    varchar(1024)                          null comment '用户头像',
    gender       tinyint                                null comment '性别',
    userPassword varchar(512)                           not null comment '密码',
    phone        varchar(128)                           null comment '电话',
    email        varchar(512)                           null comment '邮箱',
    userStatus   int          default 0                 not null comment '状态 0-正常',
    createTime   datetime     default CURRENT_TIMESTAMP null comment '创建时间',
    updateTime   datetime     default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP comment '更新时间',
    isDelete     tinyint      default 0                 not null comment '是否删除',
    role         int          default 0                 not null comment '用户角色 0-普通用户 1-管理员'
) comment '用户' charset = utf8;
```
<a name="ZaUpe"></a>
## 1.2 注册接口

1. 用户在前端输入账号和密码、以及校验
2. 校验用户的账号、密码、校验密码，是否符合要求
   1. 账号不小于4位数，可以百度校验的正则表达式
   2. 密码不小于8位
   3. 账户不能重复
   4. 账户不包含特殊字符
   5. 密码和校验密码是否相同
   6. 其它
3. 对密码进行加密 （密码千万不能直接以明文存储到数据库中）
4. 向数据库中插入用户数据
```java
public interface UserService extends IService<User> {

    /**
     * 用户注册
     * @param userAccount 用户账号
     * @param userPassword 用户密码
     * @param checkPassword 校验密码
     * @return 新用户 id
     */
    long userRegister(String userAccount,String userPassword, String checkPassword);
}
```
```java
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User>
        implements UserService {

    @Resource
    private UserMapper userMapper;

    @Override
    public long userRegister(String userAccount, String userPassword, String checkPassword) {
        // 1. 校验 isAnyBlank方法用于校验字符串是否为 null 、空
        if (StringUtils.isAnyBlank(userAccount, userPassword, checkPassword)) {
            return -1; //有一项不满足校验就返回-1
        }
        if (userAccount.length() < 4) {
            return -1;
        }
        if (userPassword.length() < 8 || checkPassword.length() < 8) {
            return -1;
        }
        //账户不能重复，查询数据库中的用户
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("userAccount", userAccount);
        long count = userMapper.selectCount(queryWrapper);
        // 如果该账户已经有人注册了
        if (count > 0) {
            return -1;
        }
        //账户不能包含特殊字符
        // 只允许字母和数字 // String regEx ="[^a-zA-Z0-9]";
        // 清除掉所有特殊字符
        String validPattern = "[` ~!@#$%^&*()+=|{}':;',\\\\[\\\\].<>/?~！@#￥%……&*（）——+|{}【】‘；：”“’。，、？]";
        Matcher matcher = Pattern.compile(validPattern).matcher(userAccount);
        if (matcher.find()) {
            return -1;
        }
        //密码和校验密码相同
        if (!userPassword.equals(checkPassword)) {
            return -1;
        }

        // 2. 加密密码
        final String SALT = "bobo"; //搅屎棍，让密码更加复杂 知道盐才能解密，防解密
        // 使用Spring提供的加密工具类，得到加密密码
        String encryptPassword = DigestUtils.md5DigestAsHex((SALT + userPassword).getBytes());

        // 3. 插入用户数据到数据库
        User user = new User();
        user.setUserAccount(userAccount);
        user.setUserPassword(encryptPassword);
        boolean saveResult = this.save(user);
        if (!saveResult) {
            return -1;
        }
        return user.getId();
        //如果上面没有插入成功，那么用户 主键id 为 null，此时返回 null ，而 UserService 接口中的方该法返回值是 long
        // 会导致数据类型 自动拆箱失败，报错
    }
}
```

```java
/**
 * @author boboking
 * @date 2023/11/3
 * @description 用户服务测试
 */
@SpringBootTest
public class UserServiceTest {

    @Resource
    private UserService userService;

    @Test
    public void testAddUser() {
        User user = new User();
        user.setUsername("bobo");
        user.setUserAccount("123");
        user.setAvatarUrl("https://c-ssl.duitang.com/uploads/blog/202201/23/20220123222213_2899a.jpeg");
        user.setGender(0);
        user.setUserPassword("123");
        user.setPhone("123456");
        user.setEmail("789");

        boolean result = userService.save(user);
        System.out.println("用户id：" + user.getId());
        // 断言
        Assertions.assertTrue(result);
    }

    // 测试用户注册
    @Test
    void userRegister() {
        String userAccount = "ripple";
        String userPassword = "";
        String checkPassword = "123456";
        long result = userService.userRegister(userAccount, userPassword, checkPassword);
        Assertions.assertEquals(-1, result);

        userAccount = "bo"; // 测试账户长度不小于 4 位数
        result = userService.userRegister(userAccount, userPassword, checkPassword);
        Assertions.assertEquals(-1, result);

        userAccount = "ripple"; // 测试密码位数 不小于8
        userPassword = "123456";
        checkPassword = "123456";
        result = userService.userRegister(userAccount, userPassword, checkPassword);
        Assertions.assertEquals(-1, result);

        userAccount = "ripp le"; // 测试特殊空格字符
        userPassword = "12345678";
        checkPassword = "12345678";
        result = userService.userRegister(userAccount, userPassword, checkPassword);
        Assertions.assertEquals(-1, result);

        userAccount = "ripple"; // 测试密码和校验密码是否一致
        userPassword = "12345678";
        checkPassword = "123456789";
        result = userService.userRegister(userAccount, userPassword, checkPassword);
        Assertions.assertEquals(-1, result);

        userAccount = "yupi"; // 测试正常密码
        userPassword = "123456789";
        checkPassword = "123456789";
        result = userService.userRegister(userAccount, userPassword, checkPassword);
        Assertions.assertEquals(-1, result);

    }
}
```
<a name="AdHoH"></a>
## 1.3 登录接口
接收参数：用户账户、密码<br />请求类型：POST <br />请求体：JSON格式的数据<br />返回值：用户信息（**脱敏**）<br />**逻辑**

1. 校验用户的账号、密码是否符合要求
   1. 非空
   2. 账号不小于4位数，可以百度校验的正则表达式
   3. 密码不小于8位
   4. 账户不包含特殊字符
2. 校验密码是否输入正确，要和数据库中的密文密码去对比
3. 用户信息**脱敏，隐藏敏感信息**，防止数据库中的字段泄露
4. 要记录用户的登陆状态，将其存放到服务器上(session)
5. 返回脱敏后的用户信息

**如何知道是哪个用户登录了？**

1. 连接服务器端后，得到一个 session 状态（匿名会话），返回给前端
2. 登录成功后，得到了登陆成功的 session ，并且给该 session 设置一些值（比如用户信息），返回给前端一个设置 cookie 的 "命令"

**session => cookie**

3. 前端接收到后端的命令后，设置 cookie ，保存到浏览器内
4. 前端再次请求后端的时候(相同的域名)，在请求头上带上 cookie 去请求
5. 后端拿到前端传来的 cookie ，找到对应的 session
6. 后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名等）
```java
public interface UserService extends IService<User> {


    /**
     * 用户注册
     *
     * @param userAccount   用户账号
     * @param userPassword  用户密码
     * @param checkPassword 校验密码
     * @return 新用户 id
     */
    long userRegister(String userAccount, String userPassword, String checkPassword);

    /**
     * 用户登录
     *
     * @param userAccount  用户账户
     * @param userPassword 用户密码
     * @param request      请求
     * @return 脱敏后的用户信息
     */
    User userLogin(String userAccount, String userPassword, HttpServletRequest request);

    /**
     * 用户信息脱敏
     *
     * @param user 数据库中查询到的用户
     * @return 脱敏处理后的用户
     */
    User getSafetyUser(User user);
}
```
```java
 @Override
    public User userLogin(String userAccount, String userPassword, HttpServletRequest request) {
        // 1. 校验 isAnyBlank方法用于校验字符串是否为 null 、空
        if (StringUtils.isAnyBlank(userAccount, userPassword)) {
            // todo 修改为自定义异常
            return null; //有一项不满足校验就返回
        }
        if (userAccount.length() < 4) {
            return null; //
        }
        if (userPassword.length() < 8) {
            return null;
        }

        //账户不能包含特殊字符
        // String regEx ="[^a-zA-Z0-9]";    // 只允许字母和数字
        String validPattern = "[` ~!@#$%^&*()+=|{}':;',\\\\[\\\\].<>/?~！@#￥%……&*（）——+|{}【】‘；：”“’。，、？]";
        Matcher matcher = Pattern.compile(validPattern).matcher(userAccount);
        if (matcher.find()) { // 如果含有特殊字符
            return null;
        }

        // 2. 加密密码
        // 使用Spring提供的加密工具类，得到加密密码
        String encryptPassword = DigestUtils.md5DigestAsHex((SALT + userPassword).getBytes());
        // 3. 查询用户是否存在
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("userAccount", userAccount); //用户输入的账户要等于数据表中的字段
        queryWrapper.eq("userPassword", encryptPassword); //用户输入的密码要等于加密后的密码

        User user = userMapper.selectOne(queryWrapper); //以上作为条件去数据库查询用户
        // 如果用户不存在
        if (null == user) {
            log.info("user login failed, userAccount cannot match userPassword"); //match(匹配)
            return null;
        }

        // 4. 把该用户信息脱敏
        User safetyUser = getSafetyUser(user);

        // 5. 记录用户的登录状态,将其存放到服务器上(session)，当前只是单个，后面可以做成分布式
        request.getSession().setAttribute(USER_LOGIN_STATE, safetyUser);

        return safetyUser;
    }
```

<a name="KvYbr"></a>
## 1.4 用户管理接口
！！！注意：必须要鉴权

1. 查询用户
   1. 允许根据用户名查询
2. 删除用户
```java
@RestController
@RequestMapping("/user")
@Slf4j
public class UserController {

    @Resource
    private UserService userService;

    @PostMapping("/register")
    public Long userRegister(@RequestBody UserRegisterRequest userRegisterRequest) {
        if (userRegisterRequest == null) {
            return null;
        }
        log.info("用户注册请求参数，{}", userRegisterRequest);
        // 前端传递过来的所有请求参数封装在 UserRegisterRequest 实体类中
        String userAccount = userRegisterRequest.getUserAccount();
        String userPassword = userRegisterRequest.getUserPassword();
        String checkPassword = userRegisterRequest.getCheckPassword();
        // 简单校验，如果这3个请求参数有一个为空
        if (StringUtils.isAnyBlank(userAccount, userPassword, checkPassword)) {
            return null;
        }
        // 调用服务层注册方法
        return userService.userRegister(userAccount, userPassword, checkPassword);
    }

    @PostMapping("/login")
    public User userLogin(@RequestBody UserLoginRequest userLoginRequest, HttpServletRequest request) {
        if (userLoginRequest == null) {
            return null;
        }
        log.info("用户登录请求参数：{}", userLoginRequest);
        // 前端传递过来的 账户、密码 参数封装在 UserLoginRequest 实体类中，而Http请求对象封装在 HttpServletRequest
        String userAccount = userLoginRequest.getUserAccount();
        String userPassword = userLoginRequest.getUserPassword();
        // 简单校验，如果这2个请求参数有一个为空
        if (StringUtils.isAnyBlank(userAccount, userPassword)) {
            return null;
        }
        return userService.userLogin(userAccount, userPassword, request);
    }

    // 根据用户名模糊查询
    @GetMapping("/search")
    public List<User> searchUsers(String username, HttpServletRequest request) {
        log.info("查询用户参数 username：{}", username);
        // 仅管理员可查询
        if (!isAdmin(request)) {
            return new ArrayList<>(); //如果不是管理员返回空列表
        }
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        // isNotBlank 判断该字符串长度是否为0、为空
        if (StringUtils.isNotBlank((username))) {
            queryWrapper.like("username", username); //模糊查询
        }

        // 把用户敏感信息过滤掉，不要返回给前端
        List<User> userList = userService.list(queryWrapper); //从数据库中查询到的用户
        List<User> safetyUsersList = new ArrayList<>(); // 脱敏处理后的用户

        for (User user : userList) {
            safetyUsersList.add(userService.getSafetyUser(user));
        }
        return safetyUsersList;
    }

    // 根据id删除用户
    @PostMapping("/delete")
    public boolean deleteUser(long id, HttpServletRequest request) {
        log.info("删除用户参数 id：{}", id);
        // 仅管理员可删除
        if (!isAdmin(request)) {
            return false;
        }
        if (id <= 0) {
            return false;
        }
        return userService.removeById(id);
    }

    /**
     * 是否为管理员
     *
     * @param request 请求对象
     * @return
     */
    private boolean isAdmin(HttpServletRequest request) {
        // 仅管理员可查询
        User userObj = (User) request.getSession().getAttribute(USER_LOGIN_STATE);
        if (userObj == null || userObj.getUserRole() != ADMIN_ROLE) {
            return false;
        }
        return true;
    }
}

```
<a name="WcB4p"></a>
## 1.5 前端项目初始化
Ant Design Pro : [https://pro.ant.design/zh-CN/docs/getting-started](https://pro.ant.design/zh-CN/docs/getting-started)<br />是基于 Ant Design 和 umi 的封装的一整套企业级中后台前端/设计解决方案
<a name="HkmgB"></a>
## 1.6 封装响应结果类-自定义错误码枚举
```java
@Data
public class BaseResponse<T> implements Serializable {

    private int code;

    private T data;

    private String massage;

    private String description;

    public BaseResponse(int code, T data, String massage, String description) {
        this.code = code;
        this.data = data;
        this.massage = massage;
        this.description = description;
    }

    // 成功
    public BaseResponse(int code, T data, String description) {
        this(code, data, "ok", description);
    }

    // 失败
    public BaseResponse(ErrorCode errorCode) {
        this(errorCode.getCode(), null, errorCode.getMessage(), errorCode.getDescription());
    }
}

```
```java
public enum ErrorCode {

    PARAMS_ERROR(40000, "请求参数错误", ""),
    NULL_ERROR(40001,"请求数据为空",""),
    NOT_LOGIN(40100,"未登录",""),
    NO_AUTH(40101,"无权限",""),
    SYSTEM_ERROR(50000, "系统内部异常", "");


    /**
     * 状态码
     */
    private final int code;

    /**
     * 状态码信息
     */
    private final String message;

    /**
     * 自定义状态码描述
     */
    private String description;


    ErrorCode(int code, String message, String description) {
        this.code = code;
        this.message = message;
        this.description = description;
    }

    public int getCode() {
        return code;
    }

    public String getMessage() {
        return message;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }
}


```
```java
public class ResultUtils {
    /**
     * 成功
     * @param data
     * @return
     * @param <T>
     */
    public static <T> BaseResponse<T> success(T data) {
        return new BaseResponse<T>(0, data, "请求成功");
    }

    /**
     * 失败
     * @param errorCode
     * @return
     */
    public static BaseResponse error(ErrorCode errorCode) {
        return new BaseResponse(errorCode);
    }

    /**
     * 失败
     * @param errorCode 错误码
     * @param description 自定义描述
     * @return
     */
    public static BaseResponse error(ErrorCode errorCode,String description) {
        errorCode.setDescription(description);
        return new BaseResponse(errorCode);
    }
}
```
<a name="f6FEM"></a>
## 1.7 封装全局异常处理

1. 自定义业务异常

a. 相对于 java 的异常类，可以自己扩展多个字段属性<br />b. 自定义多个构造函数

2. 全局异常处理器

a. 捕获代码中所有的异常，集中处理，让前端得到更加详细的业务报错/信息
```java
/**
 * @author 花海
 * @date 2023/11/9
 * @description 自定义业务异常
 */
public class BusinessException extends RuntimeException {

    private final int code;
    private final String description;

    public BusinessException(String message, int code, String description) {
        super(message);
        this.code = code;
        this.description = description;
    }

    public BusinessException(ErrorCode errorCode, String description) {
        super(errorCode.getMessage());
        this.code = errorCode.getCode();
        this.description = description;
    }

    public int getCode() {
        return code;
    }

    public String getDescription() {
        return description;
    }
}

```
```java
/**
 * @author 花海
 * @date 2023/11/9
 * @description 全局异常处理器
 */

//@RestControllerAdvice
@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ResponseBody // 使用 @RestControllerAdvice 的话可以省略该注解
    @ExceptionHandler({BusinessException.class})
    public BaseResponse businessExceptionHandler(HttpServletRequest request, BusinessException businessEx) {
        log.error("自定义业务异常：状态码={}, 信息={}, 描述={}", businessEx.getCode(), businessEx.getMessage(), businessEx.getDescription());
        return ResultUtils.error(ErrorCode.PARAMS_ERROR, businessEx.getDescription());
    }

    @ResponseBody
    @ExceptionHandler({RuntimeException.class})
    public BaseResponse runtimeExceptionHandler(HttpServletRequest request, RuntimeException e) {
        log.error("运行时异常：{}", e);
        return ResultUtils.error(ErrorCode.SYSTEM_ERROR);
    }
}

```
<a name="V7K3Y"></a>
# 2 部署上线
<a name="jhSaa"></a>
## 2.1 多环境以及前后端实战配置
参考文章：[https://blog.csdn.net/weixin_41701290/article/details/120173283](https://blog.csdn.net/weixin_41701290/article/details/120173283)<br />本地开发：localhost 127.0.0.1<br />多环境：同一套项目代码在不同的阶段需要根据实际情况来调整配置并部署到不同的机器上。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699532731361-f76a29b9-10cd-49aa-9295-e60388dda30a.png#averageHue=%23fbf9f8&clientId=uc96e7e2f-f6aa-4&from=paste&height=526&id=u8ba7a444&originHeight=1088&originWidth=1440&originalType=url&ratio=1.6500000953674316&rotation=0&showTitle=false&size=113256&status=done&style=none&taskId=uf8f47476-3c5e-4233-a811-5bd324ddf21&title=&width=696.0037231445312)<br />为什么需要多环境？**（针对不同的环境做不同的事情）**：

1. **每个环境互不影响**
2. **为了区分不同的阶段：开发/ 测试/ 生产**
3. **对项目进行优化：**
   1. 本地日志级别
   2. 精简依赖，节省项目体积
   3. 项目的环境 / 参数可以调整
4. **多环境分类** ：
   1. 本地环境 localhost。
   2. 开发环境 （远程开发）大家连同一台机器，开发方便。
   3. 测试环境（测试）：独立的数据库、独立的服务器。
   4. 预发布环境：**类似于体验服 **,基本和正式环境一致，更加严谨、查出更多问题。
   5. 正式环境（线上、对外开放访问的项目）：尽量不要改动，保证上线的代码是”完美的“。
   6. 沙箱环境（实验环境）：为了做实验
5. **前端多环境实战**

**a. 请求地址**<br />👉开发环境：localhost:8000<br />👉线上环境：http://user-center.cn
```javascript
如何实现环境地址的切换？在项目启动之前
startFront (env) {
	if (env === 'prod) {
      // 不输出注释
      // 项目优化
      // 修改请求地址
    } else {
      // 保持本地开发逻辑
	}	
}

export const request: RequestConfig = {
  // 根据环境动态改变请求地址前缀
  prefix: process.env.NODE_ENV === 'production'? 'http://user-center.cn' : 'http://localhost:8000/api',
  timeout: 100000,
};
```
**b. 启动方式**<br />开发环境**：**npm run start (本地启动，监听端口，自动更新)<br />线上环境**：**npm sun build （项目打包构建）,进入所在资源目录，可以使用 serve 工具启动 （npm i 			-g  serve 安装）
```shell
// 使用 serve 工具可以在本地 3000 端口开启一个服务器来访问静态资源
npm install serve -g  // 安装 serve

// 进入打包好的 dist 目录下启动，执行 serve，进入生产环境
serve
```
**c. 项目的配置**<br />不同的项目（框架）都有不同的配置文件，可以在配置文件后添加对应的环境名称后缀来区分开发环境和生产环境。<br />开发环境：config.dev.ts   ==> devlopment<br />生产环境：config.prod.ts  ==> production<br />公共配置：config.ts  不带后缀

6. **后端多环境实战**

SpringBoot 项目，通过 application.yml 添加不同的后缀来区分配置文件，可以在启动项目时传入环境变量指定配置文件生效。<br />主要是修改：<br />a. 依赖的环境地址：数据库地址、缓存地址、消息队列地址、项目端口号等。<br />b. 服务器配置

1. application.yml  该文件在整个项目中公共通用，即项目都会用到该文件中的所有配置
```yaml
spring:
  application:
    name: user-center
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    # 本地数据库
    username: root
    password: twb
    url: jdbc:mysql://localhost/user_center
  # 设置session会话失效时间 一天
  session:
    timeout: 86400

server:
  port: 8080
  servlet:
    context-path: /api

  # mapUnderscoreToCamelCase 是否开启自动驼峰命名规则（camel case）映射，
  #即从经典数据库列名 A_COLUMN（下划线命名） 到经典 Java 属性名 aColumn（驼峰命名） 的类似映射。

mybatis-plus:
  configuration:
    map-underscore-to-camel-case: false
  global-config:
    db-config:
      # 逻辑删除配置  官方文档：https://baomidou.com/pages/6b03c5/#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95
      logic-delete-field: isDelete # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)
      logic-delete-value: 1 # 逻辑已删除值(默认为 1)
      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)
  
```

2. application-prod.yml：该文件主要是针对生产环境的配置
```yaml
# 生产环境配置
spring:
  # 使用生产环境下的数据源
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    # 使用生产环境中的数据库地址
    username: root
    password: 123456
    url: jdbc:mysql://192.158.200.101:3306/user_center
  # 设置session会话失效时间 一天
  session:
    timeout: 86400

server:
  address: 0.0.0.0

```

3. java项目打包构建

在打包之前必须删除掉项目文件类中没有使用的一些导包语句，并且测试文件类中的方法不能出错(因为打包之前会先进行测试，也可以跳过测试环节)
```xml
maven打包出错：错误提示如下：
There are test failures.
Please refer to XXX\target\surefire-reports for the individual test results.
Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date].dumpstream.
问题描述  这是因为测试代码时遇到错误，它会停止编译。

解决方案1：在pom文件添加以下配置，打包跳过测试
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
   <artifactId>maven-surefire-plugin</artifactId>
   <configuration>
   <testFailureIgnore>true</testFailureIgnore>
   </configuration>
</plugin>

解决方案2：通过idea设置maven打包跳过测试
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699540518377-36e1033d-12dc-47a0-b02b-d001835e4933.png#averageHue=%233e444a&clientId=uc96e7e2f-f6aa-4&from=paste&height=388&id=u45bcdc0d&originHeight=641&originWidth=947&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=66887&status=done&style=none&taskId=u82cd4613-3077-49e7-bd00-586340eea9a&title=&width=573.9393607665922)

4. 运行，进入 target 目录下找到打包构建的 jar 包
```shell
// 运行 jar 包，并指定生产环境的配置文件生效
java -jar .\user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod

```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699540746246-1733c467-9fdc-4350-91f2-450f84cc5bcc.png#averageHue=%23535041&clientId=uc96e7e2f-f6aa-4&from=paste&height=698&id=u3ac039f4&originHeight=1152&originWidth=2335&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=279371&status=done&style=none&taskId=u0daa59b5-98ab-4edf-bec6-47e74a217be&title=&width=1415.151433357965)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699540947126-c9b108cb-5242-4b53-8ab2-1994dd35d019.png#averageHue=%232f2e2e&clientId=uc96e7e2f-f6aa-4&from=paste&height=448&id=u6bd6c7c0&originHeight=740&originWidth=2455&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=179982&status=done&style=none&taskId=u8e8f124a-1810-4ce5-b6fd-9b787ed9520&title=&width=1487.878701881715)

<a name="vRCP4"></a>
## 2.2 项目部署上线
<a name="fMb2s"></a>
### 原始前后端项目方式

1. 把前端打包好的项目 dist 目录以压缩包上传到虚拟机目录下，进行解压
```shell
// 解压到指定的目录
unzip dist.zip -d user-center-frontend

// 修改 nginx.conf  配置文件
vim /usr/local/nginx-1.20.2/conf/nginx.conf
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699861486448-f3cef0c7-4875-4462-bff0-0beb5fc5cf2c.png#averageHue=%23131110&clientId=u1739b61f-6a68-4&from=paste&height=507&id=uea302cad&originHeight=761&originWidth=2005&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=194231&status=done&style=none&taskId=u44a2790b-118b-456e-a9eb-3bd0aff2884&title=&width=1336.6666666666667)

2. 如果需要修改 nigix 配置，在安装目录 conf 下找到  nginx.conf  文件，修改之后需要重新加载生效
```shell
// 启动 nginx 服务
nginx

// 重新加载配置文件生效
nginx -s reload
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699859714530-f411581b-8ada-4a9d-a648-9e199ab3e88d.png#averageHue=%230c0b0a&clientId=u1f00b01a-fa65-4&from=paste&height=533&id=u4a66b873&originHeight=800&originWidth=1294&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=127067&status=done&style=none&taskId=u6d2cc7f7-b38a-436f-b447-4ef53a03cdf&title=&width=862.6666666666666)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699859899948-704a934b-a65b-4c6b-b94f-f962268967bc.png#averageHue=%23030302&clientId=u1f00b01a-fa65-4&from=paste&height=447&id=u56bb0065&originHeight=670&originWidth=1219&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=64512&status=done&style=none&taskId=u3ac7000a-a2e7-474a-9227-7ca3533371b&title=&width=812.6666666666666)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699860009496-4ef9fad1-bd67-4a10-a276-2616c8c99385.png#averageHue=%23050403&clientId=u1f00b01a-fa65-4&from=paste&height=486&id=u98dbb959&originHeight=729&originWidth=952&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=68978&status=done&style=none&taskId=u56993395-10a6-4e8c-89c2-e9de1b9166e&title=&width=634.6666666666666)

3. 访问nginx：虚拟机IP:80

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699861878148-eda7534a-4c39-4f2f-bcdb-f8616b2b3074.png#averageHue=%23e9eef4&clientId=u19df0cc1-7771-4&from=paste&height=599&id=uc6259431&originHeight=899&originWidth=1644&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=98171&status=done&style=none&taskId=ufaf0601c-6438-40da-b1a9-ba538bf7179&title=&width=1096)

4. 部署后端项目，通过 maven 打包构建项目，在IDEA target 目录下得到一个 jar 包，上传到虚拟机目录下（也可以在虚拟机安装 maven 通过：mvn  package -DskipTests   命令打包从远程仓库克隆下来的的项目代码）

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699862155617-e0e0b30c-710d-4d72-83bf-e77594791e5a.png#averageHue=%2325201f&clientId=u19df0cc1-7771-4&from=paste&height=173&id=u7c315c40&originHeight=260&originWidth=1255&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=47221&status=done&style=none&taskId=u610eaa9a-3baf-4534-ae64-d38a3e52495&title=&width=836.6666666666666)

5. 使用 java -jar 命令运行 spring boot 项目
```shell
// 打包构建，跳过测试
mvn  package -DskipTests

// nohup 表示以后台进程方式运行，注意末尾加 &
// --spring.profiles.active=prod 指定 application-prod.yml 配置文件生效
nohup java -jar user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod &

// 查看正在后台运行的java项目
jobs

// 查看进程服务
netstat -ntlp

// 查看所有已经运行java相关的程序
jps

```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699864177004-66cb38d5-5ff8-40df-af89-044d57c09d2b.png#averageHue=%230c0b0a&clientId=u19df0cc1-7771-4&from=paste&height=500&id=uf1aaae3a&originHeight=750&originWidth=2016&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=134279&status=done&style=none&taskId=uc7c86a53-a7d7-4769-ba6d-380c479d911&title=&width=1344)
<a name="btVKL"></a>
### 宝塔 Linux 方式
官网安装：[https://www.bt.cn/new/download.html](https://www.bt.cn/new/download.html)<br />宝塔命令大全：[https://www.bt.cn/new/btcode.html](https://www.bt.cn/new/btcode.html)<br />查询本机IP<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699866835043-c78004ed-8d03-4d6a-a806-3f963169b951.png#averageHue=%23fafaf9&clientId=u19df0cc1-7771-4&from=paste&height=480&id=u6628b7a4&originHeight=720&originWidth=1304&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=149368&status=done&style=none&taskId=u38f0228e-2e20-49f1-857f-7e402faaebd&title=&width=869.3333333333334)

1. Linux安装宝塔
```shell
yum install -y wget && wget -O install.sh https://download.bt.cn/install/install_6.0.sh && sh install.sh ed8484bec
```

2. 出现如下信息，安装成功

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699866979762-9fcac5aa-2ccb-4071-9335-84bd8e6a0cd2.png#averageHue=%230e0e0d&clientId=u19df0cc1-7771-4&from=paste&height=597&id=u6b520a45&originHeight=896&originWidth=1363&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=99864&status=done&style=none&taskId=uf3ad83d9-b981-4942-8772-6769663f908&title=&width=908.6666666666666)

3. 使用初始用户名和密码登录

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699867138140-0fa7a3f8-b7e9-4aec-9871-b288cb4a1b94.png#averageHue=%23767676&clientId=u19df0cc1-7771-4&from=paste&height=765&id=u01c3f8ce&originHeight=1148&originWidth=1519&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=101907&status=done&style=none&taskId=u8a52e28e-bc09-4851-b1fa-68e88c36bd8&title=&width=1012.6666666666666)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699867781232-c4b42e57-6adf-4cd1-bd91-3753bf4bc436.png#averageHue=%23fcfbfb&clientId=u19df0cc1-7771-4&from=paste&height=633&id=ua9262506&originHeight=950&originWidth=1522&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=134405&status=done&style=none&taskId=u7051513a-38a3-4872-8a71-6fe9f36c938&title=&width=1014.6666666666666)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699867842312-b222a9ca-afc1-4ed6-b397-08c15b4570c8.png#averageHue=%23fcfaf9&clientId=u19df0cc1-7771-4&from=paste&height=506&id=uf3002a63&originHeight=759&originWidth=1548&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=124446&status=done&style=none&taskId=ue1ec6fda-af06-466d-a3fe-56de1fed3dc&title=&width=1032)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699871370713-631ce3fa-cf2d-4c38-a8c0-5049db9c36f8.png#averageHue=%23100f0f&clientId=u19df0cc1-7771-4&from=paste&height=505&id=u019ca372&originHeight=758&originWidth=1989&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=146425&status=done&style=none&taskId=u8f6c36b8-7ba1-4618-9c09-fc685ad0856&title=&width=1326)

4.  为什么我在Linux部署的Springboot服务，部署成功之后，使用netstat -ntlp | grep java 命令查看对应服务监听的端口，只看到有tcp6的监听，没有tcp的监听？

参考文章：[https://blog.csdn.net/qq_40596572/article/details/131413286?](https://blog.csdn.net/qq_40596572/article/details/131413286?)

5. 记得放行项目端口，否则无法访问（重点！！！）

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699872075521-573aea27-642b-412a-a975-380e4f28ecfd.png#averageHue=%23fbfbfb&clientId=u19df0cc1-7771-4&from=paste&height=551&id=ub4690a25&originHeight=827&originWidth=2162&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=114608&status=done&style=none&taskId=u83502a20-8fc7-45c4-86ff-a5b5542987c&title=&width=1441.3333333333333)
<a name="Qknq3"></a>
### docker 容器方式
docker是容器，可以把项目的环境（比如：java、nginx、tomcat）和项目的代码一起打包成镜像，可以下载镜像，更容易分发和移植，在启动项目时，不用执行一大堆命令，而是直接下载镜像，启动镜像即可。docker可以理解为软件安装包。<br />Docker官网安装：[https://www.docker.com/get-started/](https://www.docker.com/get-started/)   或者在宝塔里面安装

1. 在宝塔的软件商店里安装Docker管理器后，可以在自己的虚拟机上执行   docker -v  查看版本信息：

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699872766682-d65d2510-fa11-4029-a042-8d690c6f1bab.png#averageHue=%23f9f9f9&clientId=u19df0cc1-7771-4&from=paste&height=343&id=u9177efb2&originHeight=514&originWidth=1336&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=49494&status=done&style=none&taskId=u3efe243a-bd45-4c7c-9448-d46e5136818&title=&width=890.6666666666666)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699872674843-06d9cfc8-ded9-4d89-bc11-14d3a81f9117.png#averageHue=%23353433&clientId=u19df0cc1-7771-4&from=paste&height=165&id=u679638f2&originHeight=247&originWidth=1086&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=27266&status=done&style=none&taskId=u62645b70-fcbc-4ba4-8b0d-fc4b8831289&title=&width=724)

2. 怎么把项目的环境和代码打包成镜像？----> Dockerfile  用于指定构建 Docker镜像

Dockerfile 一般情况下不需要从0开始写，建议参考网上同类别项目，如下配置：<br />Dockerfile后端：
```shell
# 依赖的基础镜像
FROM maven:3.5-jdk-8-alpine as builder

# Copy local code to the container image.
# 工作目录
WORKDIR /app
COPY pom.xml .
COPY src ./src

# Build a release artifact.
# 打包构建，跳过测试
RUN mvn package -DskipTests

# Run the web service on container startup.
# 启动运行镜像的时候，默认执行该命令(在启动时可以指定或修改命令参数)
CMD ["java","-jar","/app/target/user-center-backend-0.0.1-SNAPSHOT.jar","--spring.profiles.active=prod"]
```

Dockerfile前端：
```shell
FROM nginx

WORKDIR /usr/share/nginx/html/
USER root

COPY ./docker/nginx.conf /etc/nginx/conf.d/default.conf

COPY ./dist  /usr/share/nginx/html/

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]

```
前端Docker nginx 配置：
```shell
server {
    listen 80;

    # gzip config
    gzip on;
    gzip_min_length 1k;
    gzip_comp_level 9;
    gzip_types text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml;
    gzip_vary on;
    gzip_disable "MSIE [1-6]\.";

    root /usr/share/nginx/html;
    include /etc/nginx/mime.types;

    location / {
        try_files $uri /index.html;
    }

}
```

3. Docker 打包镜像

Docker菜鸟教程：[https://www.runoob.com/docker/docker-build-command.html](https://www.runoob.com/docker/docker-build-command.html)
```shell
实例
使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。
docker build -t runoob/ubuntu:v1 . 

使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。
docker build github.com/creack/docker-firefox

也可以通过 -f Dockerfile 指定文件的位置：
docker build -f /path/to/a/Dockerfile .


使用 docker images 来列出本地主机上的镜像
docker images

在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回：
docker build -t test/myapp .
Sending build context to Docker daemon 2.048 kB
Error response from daemon: Unknown instruction: RUNCMD
```
注意：**在使用dockerfile打包镜像的时候，建议把项目代码克隆git clone 或者上传到Linux 虚拟机目录下，并在当前目录下执行docker的打包命令，保证有 Dockerfile 文件**
```shell
# 后端 打包镜像
docker build -t user-center-backend:v0.0.1 . 

# 前端 打包镜像
docker build -t user-center-frontend:v0.0.1 . 

# 列出本地主机上已经构建出来的的镜像
docker images
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699878404188-c7f527b2-4244-4fcf-84cb-816b8caaeb7e.png#averageHue=%230b0b0a&clientId=u19df0cc1-7771-4&from=paste&height=335&id=u5c75a69f&originHeight=503&originWidth=2167&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=94996&status=done&style=none&taskId=u7d56d789-82b6-4e7e-8e9b-abf0b9554ba&title=&width=1444.6666666666667)

4. Docker 构建优化：减少尺寸大小、减少构建时间（比如多阶段构建，丢弃不需要的步骤内容）
5. 启动运行Docker 镜像 
```shell
// 启动镜像
docker run
```
<a name="uFFJN"></a>
### 容器平台方式
.......
<a name="s0kSr"></a>
## 2.3 使用宝塔Linux部署项目踩坑问题-容易出错的相关配置
nginx 跨域配置代理：
```shell
location /api {
      proxy_pass http://127.0.0.1:8080;  
      add_header 'Access-Control-Allow-Origin' $http_origin;
      add_header 'Access-Control-Allow-Credentials' 'true';
      add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
      add_header Access-Control-Allow-Headers '*';
      if ($request_method = 'OPTIONS') {
        add_header 'Access-Control-Allow-Origin' $http_origin;
        add_header 'Access-Control-Allow-Credentials' 'true';
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
        add_header 'Access-Control-Allow-Headers'
        'DNT,web-token,app-token,Authorization,Accept,Origin,Keep-Alive,User-Agent,X-Mx-ReqToken,X-Data-Type,X-Auth-Token,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range';
        add_header 'Access-Control-Max-Age' 1728000;
        add_header 'Content-Type' 'text/plain; charset=utf-8';
        add_header 'Content-Length' 0;
        return 204;
      }
    }
```
mysql 服务启动报错问题 1： Starting MySQL. ERROR! The server quit without updating PID file (/usr/local/mysql/mysql.pid) <br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699948499464-0c3663c3-0d4e-47ff-b34a-bccc0f0824cc.png#averageHue=%230d0b0a&clientId=u17d81284-4398-4&from=paste&height=341&id=HsqzS&originHeight=511&originWidth=1785&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=147465&status=done&style=none&taskId=u657a2bcf-03f1-4f66-94b7-1fb73ca086c&title=&width=1190)<br />mysql 客户端首次登录报错 2：Can't connect to local MySQL server through socket '/tmp/mysql.sock'<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699951613518-06b9c436-c9e9-4cde-b751-d822825ddbbb.png#averageHue=%230a0908&clientId=u17d81284-4398-4&from=paste&height=210&id=QSoCZ&originHeight=315&originWidth=1861&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=96465&status=done&style=none&taskId=u951a9449-edf3-498b-b9e4-f9eeb6e2c73&title=&width=1240.6666666666667)<br />mysql 自定义 my.cnf  配置文件如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699951876366-6c6e7cf8-6aaf-437c-bcd3-f567d54dc31b.png#averageHue=%23050404&clientId=u17d81284-4398-4&from=paste&height=120&id=xjywP&originHeight=180&originWidth=1675&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=29468&status=done&style=none&taskId=uca925305-0251-433c-b0f0-d1340166fa4&title=&width=1116.6666666666667)
```shell
[client]
#客户端设置
port=3306
default-character-set=utf8
socket=/var/lib/mysql/mysql.sock
[mysqld]
port=3306
#为MySQL客户端程序和服务器之间的本地通讯指定一个套接字文件
socket=/var/lib/mysql/mysql.sock
#端口绑定的ip地址，0.0.0.0表示允许所有远程访问，127.0.0.1表示只能本机访问，默认值为*
bind-address=0.0.0.0
#默认名为 主机名.pid,在数据库/mysql/data/主机名.pid,记录mysql运行的process id
#如果存在，再次start时会报已经启动
pid-file=/usr/local/mysql/mysql.pid
#安装目录
basedir=/usr/local/mysql
#数据库存放目录
datadir=/usr/local/mysql/data
#系统数据库编码设置，排序规则
character_set_server=utf8
lower_case_table_names=1
max_connections=512
##错误日志：记录启动，运行，停止mysql时出现的信息
log-error=/data/mysql/logs/error.log
#默认使用InnoDB存储引擎
default_storage_engine=INNODB

```
<a name="iZxm3"></a>
## 2.4 前后端关键配置文件-请求联调-跨域问题
前端项目代理配置：
```typescript
export default {
  dev: {
    //前端请求的 url ===> http://localhost:8000/api/
    //后端项目的 url ===> http://localhost:8080/api/
    
    '/api': {
      // 要代理的地址
      target: 'http://localhost:8080',
      // 配置了这个可以从 http 代理到 https
      // 依赖 origin 的功能可能需要这个，比如 cookie
      changeOrigin: true,
    },
  },
  // test: {
  //   '/api/': {
  //     target: 'https://proapi.azurewebsites.net',
  //     changeOrigin: true,
  //     pathRewrite: { '^': '' },
  //   },
  // },
  // pre: {
  //   '/api/': {
  //     target: 'your pre url',
  //     changeOrigin: true,
  //     pathRewrite: { '^': '' },
  //   },
  // },
};
```
前端项目请求前缀配置：
```typescript
export const request: RequestConfig = {
  //前端请求的 url ===> http://localhost:8000/api/
  //后端项目的 url ===> http://localhost:8080/api/
  
  prefix: '/api',
  // prefix: process.env.NODE_ENV === 'production'? 'http://user-center.cn' : '/api',
  timeout: 100000,
};
```
后端项目配置：
```yaml
spring:
  application:
    name: user-center
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    # 本地数据库
    username: root
    password: twb
    url: jdbc:mysql://localhost/user_center
  # 设置session会话失效时间 一天
  session:
    timeout: 86400

server:
  port: 8080
  servlet:
  # //后端项目的 url ===> http://localhost:8080/api/
    context-path: /api

# mapUnderscoreToCamelCase 是否开启自动驼峰命名规则（camel case）映射，
#即从经典数据库列名 A_COLUMN（下划线命名） 到经典 Java 属性名 aColumn（驼峰命名） 的类似映射。
mybatis-plus:
  configuration:
    map-underscore-to-camel-case: false
  global-config:
    db-config:
      # 逻辑删除配置  官方文档：https://baomidou.com/pages/6b03c5/#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95
      logic-delete-field: isDelete # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)
      logic-delete-value: 1 # 逻辑已删除值(默认为 1)
      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)
```
```yaml
# 生产环境配置（Linux 虚拟机服务器）
spring:
  # 使用生产环境下的数据源
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    # 使用生产环境中（Linux 虚拟机服务器IP）的数据库地址
    username: root
    password: 123456
    url: jdbc:mysql://192.158.200.101:3306/user_center
  # 设置session会话失效时间 一天
  session:
    timeout: 86400

server:
  address: 0.0.0.0
```

nginx 代理配置、跨域问题：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699952304116-f185ddd5-fff6-4471-a445-34eb46f18799.png#averageHue=%23d1d1d0&clientId=u17d81284-4398-4&from=paste&height=909&id=udb4103d4&originHeight=1364&originWidth=2417&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=421105&status=done&style=none&taskId=uea08b414-c329-405f-b254-66437737d4a&title=&width=1611.3333333333333)
```shell
location /api {
  proxy_pass http://127.0.0.1:8080;  
  add_header 'Access-Control-Allow-Origin' $http_origin;
  add_header 'Access-Control-Allow-Credentials' 'true';
  add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
  add_header Access-Control-Allow-Headers '*';
  if ($request_method = 'OPTIONS') {
    add_header 'Access-Control-Allow-Origin' $http_origin;
    add_header 'Access-Control-Allow-Credentials' 'true';
    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
    add_header 'Access-Control-Allow-Headers'
    'DNT,web-token,app-token,Authorization,Accept,Origin,Keep-Alive,User-Agent,X-Mx-ReqToken,X-Data-Type,X-Auth-Token,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range';
    add_header 'Access-Control-Max-Age' 1728000;
    add_header 'Content-Type' 'text/plain; charset=utf-8';
    add_header 'Content-Length' 0;
    return 204;
  }
}
```
<a name="RW1Q8"></a>
## 2.5 前后端分离项目部署流程
<a name="tPjpo"></a>
### 2.5.1 前端部署

1. 把前端项目打包构建好的  dist  目录下的所有文件上传到 Linux 虚拟机服务器的某个目录下，在配置 nginx.conf  文件时，保证准确定位并指明 nginx 访问的根目录 /root 路径   让dist目录下的文件正常访问

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699954298822-707f76dd-f3c8-4694-a0ea-7db7528c476a.png#averageHue=%23141211&clientId=u17d81284-4398-4&from=paste&height=484&id=u92482113&originHeight=726&originWidth=1916&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=196410&status=done&style=none&taskId=u2bf00a66-ea51-4160-80b1-996746470c1&title=&width=1277.3333333333333)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699954517926-a3bf6c2a-52a3-4d2c-99a2-bc3c2fc15377.png#averageHue=%23121110&clientId=u17d81284-4398-4&from=paste&height=250&id=u5d679da9&originHeight=375&originWidth=1855&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=82291&status=done&style=none&taskId=u70679c6a-ea6b-4446-9079-793be99c525&title=&width=1236.6666666666667)<br />nginx 关键配置：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699955042915-d7c0c03c-2946-40a7-a74b-911946ade2f1.png#averageHue=%23020202&clientId=u17d81284-4398-4&from=paste&height=442&id=ua3a5bd6f&originHeight=663&originWidth=1003&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=57104&status=done&style=none&taskId=ube60b721-573d-42aa-a1c7-079b0106385&title=&width=668.6666666666666)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699954971451-a74b5072-574b-46f3-968a-65180ab69066.png#averageHue=%23030302&clientId=u17d81284-4398-4&from=paste&height=508&id=u720ac055&originHeight=762&originWidth=1175&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=131379&status=done&style=none&taskId=u0b01ace2-0205-4e6f-9744-b26382d87ed&title=&width=783.3333333333334)

2. 使用宝塔Linux部署前端项目

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699955487077-4fdf7ad0-7ff1-438d-b4d7-2a10d11c6ca3.png#averageHue=%23988056&clientId=u17d81284-4398-4&from=paste&height=795&id=u187941f0&originHeight=1193&originWidth=1495&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=220135&status=done&style=none&taskId=u4b574547-c685-4a68-ac8e-3b72736ad5d&title=&width=996.6666666666666)

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699955586680-e38826ff-be08-4a61-838b-093720162535.png#averageHue=%23d4d4d3&clientId=u17d81284-4398-4&from=paste&height=613&id=u8f7ff895&originHeight=920&originWidth=1552&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=159870&status=done&style=none&taskId=u7aa8a50d-154a-4bab-a1bf-6ed5185a55b&title=&width=1034.6666666666667)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699955889368-27c2fa75-5e02-4145-8271-c37914cd300e.png#averageHue=%23d0d0d0&clientId=u17d81284-4398-4&from=paste&height=779&id=u3d7fad38&originHeight=1168&originWidth=2082&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=297590&status=done&style=none&taskId=u7cbeb3ce-9e8f-4e6a-909c-bba8f97d0f2&title=&width=1388)<br />添加的配置代理如下：
```shell
location /api {
      proxy_pass http://127.0.0.1:8080;  
      add_header 'Access-Control-Allow-Origin' $http_origin;
      add_header 'Access-Control-Allow-Credentials' 'true';
      add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
      add_header Access-Control-Allow-Headers '*';
      if ($request_method = 'OPTIONS') {
        add_header 'Access-Control-Allow-Origin' $http_origin;
        add_header 'Access-Control-Allow-Credentials' 'true';
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
        add_header 'Access-Control-Allow-Headers'
        'DNT,web-token,app-token,Authorization,Accept,Origin,Keep-Alive,User-Agent,X-Mx-ReqToken,X-Data-Type,X-Auth-Token,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range';
        add_header 'Access-Control-Max-Age' 1728000;
        add_header 'Content-Type' 'text/plain; charset=utf-8';
        add_header 'Content-Length' 0;
        return 204;
      }
    }
```
<a name="GxVUl"></a>
### 2.5.2 后端部署

1. 把后端项目打包构建好的  jar  包（IDEA使用maven打包并跳过测试，在 target目录下生成一个 jar 包）上传到 Linux 虚拟机中或者通过宝塔上传，使用 java  -jar 命令运行启动项目。
```shell
1. maven打包出错：错误提示如下：
There are test failures.
Please refer to XXX\target\surefire-reports for the individual test results.
Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date].dumpstream.
问题描述  这是因为测试代码时遇到错误，它会停止编译。

解决方案1：在pom文件添加以下配置，打包跳过测试
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
   <artifactId>maven-surefire-plugin</artifactId>
   <configuration>
   <testFailureIgnore>true</testFailureIgnore>
   </configuration>
</plugin>

解决方案2：通过idea设置maven打包跳过测试


2. 原始后端项目启动命令，以部署在Linux虚拟机上为例
// 打包构建，跳过测试（执行该命令需要安装 Maven）
mvn  package -DskipTests

// nohup 表示以后台进程方式运行，注意末尾加 &
// --spring.profiles.active=prod 指定 application-prod.yml 配置文件生效
nohup java -jar user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod &

// 查看正在后台运行的java项目
jobs

// 查看进程服务
netstat -ntlp

// 查看所有已经运行java相关的程序
jps
```

2. 使用宝塔Linux部署后端java项目：

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35352732/1699956709272-341cb607-3d83-48e3-915b-60014825b718.png#averageHue=%23dadada&clientId=u17d81284-4398-4&from=paste&height=768&id=udddbe18e&originHeight=1152&originWidth=1508&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=200302&status=done&style=none&taskId=uc1cec0c0-e178-454d-b31b-e65016fa57b&title=&width=1005.3333333333334)
